<wiki:toc max_depth="2" />
=1. 编写测试 =

在你编写测试之前，你需要配置并安装*TestNG++*。

==1.1 测试文件==

为了使用*TestNG++*，你首先要创建放置测试代码的源代码文件，尽管并不是强制的约束，但建议使用".h"作为这些文件的扩展名。

比如，我们要测试的类名为DLModuleLoader，所以，我们可以将我们的测试文件命名为TestDLModuleLoader.h。

==1.2 头文件==

然后，你需要包含*TestNG++*的头文件 _*testngpp.hpp*_ ；像这样：
{{{
#include <testngpp/testngpp.hpp>
}}}

为了能够让编译通过，不要忘记把 *TestNG++* 的安装路径的include放到编译选项里。假如 *TestNG++* 的头文件被安装到/usr/local/include下，则你需要确保/usr/local/include被指定在你的编译选项里。对于windows用户而言，假设 *TestNG++* 被安装在c:\testngpp，则你需要将路径c:\testngpp\include放到你的编译选项里。

==1.3 FIXTURE==

下面，我们需要定义一个 *fixture*:

{{{
#include <testngpp/testngpp.hpp>

#include "DLModuleLoader.h"

FIXTURE(DLModuleLoader)
{
};

}}}

*FIXTURE()* 的第一个参数为 *Fixture ID* ，它可以是任何C/C++标识符（Identifier）。一般而言，将其命名为 *CUT* (_Class Under Test_)的名字即可。

*FIXTURE()* 还有第二个可选参数：*Fixture Name* 。它可以是任何_宏参数_所允许的字符。如果你的编译器支持多语言，你可以使用任何其它字符集所支持的字符。比如：

{{{
#include <testngpp/testngpp.hpp>

#include "DLModuleLoader.h"

FIXTURE(DLModuleLoader, 类DLModuleLoader的测试, 你可以在fixture name中使用这些字符：(){}[]''~!@#$%^&*+-=_?><"")
{
};

}}}

*FIXTURE* 本身是一个宏，所以要求*fixture name* 必须遵守宏参数的语法规则，你可以在名字里使用() ' "等符号，但它们必须正确的成对出现，否则编译器将会报错。

如果你没有提供 *fixture name* ，则 *fixture ID* 将被当作 *fixture name* 。

==1.4 TEST==

在定义了fixture之后，你可以编写你的第一个测试。如下：

{{{
#include <testngpp/testngpp.hpp>

#include "DLModuleLoader.h"

FIXTURE(DLModuleLoader)
{
   TEST(should be able to load modules whose name does not have suffix ".so")
   {
      DLModuleLoader* loader = new DLModuleLoader();
  
      ASSERT_THROWS_NOTHING(loader->load("libMySuite"));

      delete loader;
   }
};

}}}

*TEST()* 用来定义一个测试用例。括号里面的部分是 *test name* ，和 *fixture name* 一样，它可以使用你的编译器和所允许的任何字符。并且，同样也要遵守宏参数的语法约束。

比如，我可以将上面的测试用例用中文来命名：
{{{
#include <testngpp/testngpp.hpp>

#include "DLModuleLoader.h"

FIXTURE(DLModuleLoader)
{
   TEST(可以在不需要指明后缀".so"的情况下加载一个模块)
   {
      DLModuleLoader* loader = new DLModuleLoader();
  
      ASSERT_THROWS_NOTHING(loader->load("libMySuite"));

      delete loader;
   }
};

}}}

==1.5 Assertion==

测试用例里面的 *ASSERT_THROWS_NOTHING* 是一个测试断言，如果断言失败，则此测试用例将会失败。

TestNG++提供的测试断言如下：

|| 断言 || 用法 || 例子 ||
|| ASSERT_TRUE(expr) || 断言表达式的求值为true || ASSERT_TRUE(10 == a) ||
|| ASSERT_FALSE(expr) || 断言表达式的求值为false || ASSERT_FALSE(10 != a) ||
|| ASSERT_EQ(expected, value) || 断言两个表达式相等 || ASSERT_EQ(10, a) ||
|| ASSERT_NE(expected, value) || 断言两个表达式不相等 || ASSERT_NE(10, a) ||
|| ASSERT_SAME_DATA(addr1, addr2, size) || 断言两个地址所指向的内存在size范围内完全相同 || ASSERT_SAME_DATA(p1, p2, 64) ||
|| ASSERT_DELTA(x, y, delta) || 断言表达式的差值应该在delta的范围之内 || ASSERT_DELTA(9.91, 10, 0.1) ||
|| ASSERT_THROWS(expr, except) || 断言表达式将会抛出except类型的异常 || ASSERT_THROWS(foo(), std::exception) ||
|| ASSERT_THROWS_ANYTHING(expr) || 断言表达式将会抛出异常 || ASSERT_THROWS_ANYTHING(foo()) ||
|| ASSERT_THROWS_NOTHING(expr) || 断言expr不会抛出任何异常 || ASSERT_THROWS_NOTHING(foo()) ||
|| ASSERT_THROWS_EQUALS(expr, except, expected, value) || 断言表达式将会抛出except类型的异常，并且两个表达式相等 || ASSERT_THROWS_EQUALS(foo(), std::exception& e, "bad alloc", e.what()) ||

这些断言的都遵从了"快速失败"的原则，即一旦断言失败，整个用例将中止执行。结果是，对于这个例子，如果断言失败将会造成内存泄露。

{{{
   TEST(可以在不需要指明后缀".so"的情况下加载一个模块)
   {
      DLModuleLoader* loader = new DLModuleLoader();
  
      ASSERT_THROWS_NOTHING(loader->load("libMySuite"));

      delete loader; // 如果上面的断言失败，此语句将得不到执行
   }
}}}

所以，TestNG++提供了另外一套Assertion，以让断言失败后，测试能够继续得以执行。这些Assertion如下：

|| 断言 || 用法 || 例子 ||
|| EXPECT_TRUE(expr) || 断言表达式的求值为true || EXPECT_TRUE(10 == a) ||
|| EXPECT_FALSE(expr) || 断言表达式的求值为false || EXPECT_FALSE(10 != a) ||
|| EXPECT_EQ(expected, value) || 断言两个表达式相等 || EXPECT_EQ(10, a) ||
|| EXPECT_NE(expected, value) || 断言两个表达式不相等 || EXPECT_NE(10, a) ||
|| EXPECT_SAME_DATA(addr1, addr2, size) || 断言两个地址所指向的内存在size范围内完全相同 || EXPECT_SAME_DATA(p1, p2, 64) ||
|| EXPECT_DELTA(x, y, delta) || 断言表达式的差值应该在delta的范围之内 || EXPECT_DELTA(9.91, 10, 0.1) ||
|| EXPECT_THROWS(expr, except) || 断言表达式将会抛出except类型的异常 || EXPECT_THROWS(foo(), std::exception) ||
|| EXPECT_THROWS_ANYTHING(expr) || 断言表达式将会抛出异常 || EXPECT_THROWS_ANYTHING(foo()) ||
|| EXPECT_THROWS_NOTHING(expr) || 断言expr不会抛出任何异常 || EXPECT_THROWS_NOTHING(foo()) ||
|| EXPECT_THROWS_EQUALS(expr, except, expected, value) || 断言表达式将会抛出except类型的异常，并且两个表达式相等 || EXPECT_THROWS_EQUALS(foo(), std::exception& e, "bad alloc", e.what()) ||

这样，上面用例就可以改写为：

{{{
   TEST(可以在不需要指明后缀".so"的情况下加载一个模块)
   {
      DLModuleLoader* loader = new DLModuleLoader();
  
      EXPECT_THROWS_NOTHING(loader->load("libMySuite"));

      delete loader; // 即使上面的断言失败，此语句仍将得到执行
   }
}}}

==1.6 SETUP和TEARDOWN==

在测试成功运行之后，我们来编写第二个用例。

{{{
#include <testngpp/testngpp.hpp>

#include "DLModuleLoader.h"

FIXTURE(DLModuleLoader)
{
   TEST(可以在不需要指明后缀".so"的情况下加载一个模块)
   {
      DLModuleLoader* loader = new DLModuleLoader();
  
      ASSERT_THROWS_NOTHING(loader->load("libMySuite"));

      delete loader;
   }

   TEST(可以在指明后缀".so"的情况下加载一个模块)
   {
      DLModuleLoader* loader = new DLModuleLoader();
  
      ASSERT_THROWS_NOTHING(loader->load("libMySuite.so"));

      delete loader;
   }
};

}}}

然后我们发现，两个用例都需要使用一个loader实例，所以我们把这个实例定义移到fixture里面，并使用fixture的 *SETUP* 和 *TEARDOWN* ：


{{{
#include <testngpp/testngpp.hpp>

#include "DLModuleLoader.h"

FIXTURE(DLModuleLoader)
{
   DLModuleLoader* loader;
   
   SETUP()
   {
      loader = new DLModuleLoader();
   }

   TEARDOWN()
   {
      delete loader;
   }

   TEST(可以在不需要指明后缀".so"的情况下加载一个模块)
   {
      ASSERT_THROWS_NOTHING(loader->load("libMySuite"));
   }

   TEST(可以在指明后缀".so"的情况下加载一个模块)
   { 
      ASSERT_THROWS_NOTHING(loader->load("libMySuite.so"));
   }
};

}}}

像任何正确实现的xUnit框架一样，*TestNG++* 会为每个测试用例创建一个Fixture实例，并执行其 *SETUP* 和 *TEARDOWN* 。对于本例中的两个用例，其执行过程分别如下：

  # new FixtureDLModuleLoader() 
  # SETUP() 
  # TEST(可以在不需要指明后缀".so"的情况下加载一个模块) 
  # TEARDOWN() 
  # delete FixtureDLModuleLoader;

  # new FixtureDLModuleLoader() 
  # SETUP() 
  # TEST(可以在指明后缀".so"的情况下加载一个模块) 
  # TEARDOWN() 
  # delete FixtureDLModuleLoader;

==1.7 测试依赖==

随后我们编写针对unload的测试，传统的做法如下：

{{{
#include <testngpp/testngpp.hpp>

#include "DLModuleLoader.h"

FIXTURE(DLModuleLoader)
{
   DLModuleLoader* loader;
   
   SETUP()
   {
      loader = new DLModuleLoader();
   }

   TEARDOWN()
   {
      delete loader;
   }

   TEST(可以在不需要指明后缀".so"的情况下加载一个模块)
   {
      ASSERT_THROWS_NOTHING(loader->load("libMySuite"));
   }

   TEST(可以在指明后缀".so"的情况下加载一个模块)
   { 
      ASSERT_THROWS_NOTHING(loader->load("libMySuite.so"));
   }

   TEST(可以在加载后卸载模块)
   {
      ASSERT_THROWS_NOTHING(loader->load("libMySuite.so"));
      ASSERT_THROWS_NOTHING(loader->unload());
   }
};

}}}

由于卸载的前提是先加载模块，而加载模块的测试我们已经编写过，所以我们不想重复这段代码。另外一个选择是：使用测试依赖。改写结果如下：

{{{
#include <testngpp/testngpp.hpp>

#include "DLModuleLoader.h"

FIXTURE(DLModuleLoader)
{
   DLModuleLoader* loader;
   
   SETUP()
   {
      loader = new DLModuleLoader();
   }

   TEARDOWN()
   {
      delete loader;
   }

   TEST(可以在不需要指明后缀".so"的情况下加载一个模块)
   {
      ASSERT_THROWS_NOTHING(loader->load("libMySuite"));
   }

   // @ test (id=load)
   TEST(可以在指明后缀".so"的情况下加载一个模块)
   { 
      ASSERT_THROWS_NOTHING(loader->load("libMySuite.so"));
   }

   // @ test (depends=load)
   TEST(可以在加载后卸载模块)
   {
      ASSERT_THROWS_NOTHING(loader->unload());
   }
};

}}}

通过annotation属性id来标注加载测试用例，然后用属性depends来引入依赖。

引入测试依赖后，最后一个测试用例的执行过程如下：

  # new FixtureDLModuleLoader() 
  # SETUP()
  # TEST(可以在指明后缀".so"的情况下加载一个模块)
  # TEST(可以在加载后卸载模块)
  # TEARDOWN() 
  # delete FixtureDLModuleLoader;

在这个过程中，即便TEST(可以在指明后缀".so"的情况下加载一个模块)里面的断言失败，*TestNG++*仍然认为是用例TEST(可以在加载后卸载模块)失败。