<wiki:toc max_depth="2" />
=1. 编写测试 =

在你编写测试之前，你需要配置并安装*TestNG++*。

==1.1 测试文件==

为了使用*TestNG++*，你首先要创建放置测试代码的源代码文件，尽管并不是强制的约束，但建议使用".h"作为这些文件的扩展名。

比如，我们要测试的类名为DLModuleLoader，所以，我们可以将我们的测试文件命名为TestDLModuleLoader.h。

==1.2 头文件==

然后，你需要包含*TestNG++*的头文件 _*testngpp.hpp*_ ；像这样：
{{{
#include <testngpp/testngpp.hpp>
}}}

为了能够让编译通过，不要忘记把 *TestNG++* 的安装路径的include放到编译选项里。假如 *TestNG++* 的头文件被安装到/usr/local/include下，则你需要确保/usr/local/include被指定在你的编译选项里。对于windows用户而言，假设 *TestNG++* 被安装在c:\testngpp，则你需要将路径c:\testngpp\include放到你的编译选项里。

==1.3 FIXTURE==

下面，我们需要定义一个 *fixture*:

{{{
#include <testngpp/testngpp.hpp>

#include "DLModuleLoader.h"

FIXTURE(DLModuleLoader)
{
};

}}}

*FIXTURE()* 的第一个参数为 *Fixture ID* ，它可以是任何C/C++标识符（Identifier）。一般而言，将其命名为 *CUT* (_Class Under Test_)的名字即可。

*FIXTURE()* 还有第二个可选参数：*Fixture Name* 。它可以是任何_宏参数_所允许的字符。如果你的编译器支持多语言，你可以使用任何其它字符集所支持的字符。比如：

{{{
#include <testngpp/testngpp.hpp>

#include "DLModuleLoader.h"

FIXTURE(DLModuleLoader, 类DLModuleLoader的测试, 你可以在fixture name中使用这些字符：(){}[]''~!@#$%^&*+-=_?><"")
{
};

}}}

*FIXTURE* 本身是一个宏，所以要求*fixture name* 必须遵守宏参数的语法规则，你可以在名字里使用() ' "等符号，但它们必须正确的成对出现，否则编译器将会报错。

如果你没有提供 *fixture name* ，则 *fixture ID* 将被当作 *fixture name* 。

==1.4 TEST==

在定义了fixture之后，你可以编写你的第一个测试。如下：

{{{
#include <testngpp/testngpp.hpp>

#include "DLModuleLoader.h"

FIXTURE(DLModuleLoader)
{
   TEST(should be able to load modules whose name does not have suffix ".so")
   {
      DLModuleLoader* loader = new DLModuleLoader();
  
      ASSERT_THROWS_NOTHING(loader->load("libMySuite"));

      delete loader;
   }
};

}}}

*TEST()* 用来定义一个测试用例。括号里面的部分是 *test name* ，和 *fixture name* 一样，它可以使用你的编译器和所允许的任何字符。并且，同样也要遵守宏参数的语法约束。

比如，我可以将上面的测试用例用中文来命名：
{{{
#include <testngpp/testngpp.hpp>

#include "DLModuleLoader.h"

FIXTURE(DLModuleLoader)
{
   TEST(可以在不需要指明后缀".so"的情况下加载一个模块)
   {
      DLModuleLoader* loader = new DLModuleLoader();
  
      ASSERT_THROWS_NOTHING(loader->load("libMySuite"));

      delete loader;
   }
};

}}}

测试用例里面的 *ASSERT_THROWS_NOTHING* 是一个测试断言，如果断言失败，则此测试用例将会失败。

==1.5 SETUP和TEARDOWN==

在测试成功运行之后，我们来编写第二个用例。

{{{
#include <testngpp/testngpp.hpp>

#include "DLModuleLoader.h"

FIXTURE(DLModuleLoader)
{
   TEST(可以在不需要指明后缀".so"的情况下加载一个模块)
   {
      DLModuleLoader* loader = new DLModuleLoader();
  
      ASSERT_THROWS_NOTHING(loader->load("libMySuite"));

      delete loader;
   }

   TEST(可以在指明后缀".so"的情况下加载一个模块)
   {
      DLModuleLoader* loader = new DLModuleLoader();
  
      ASSERT_THROWS_NOTHING(loader->load("libMySuite.so"));

      delete loader;
   }
};

}}}

然后我们发现，两个用例都需要使用一个loader实例，所以我们把这个实例定义移到fixture里面，并使用fixture的 *SETUP* 和 *TEARDOWN* ：


{{{
#include <testngpp/testngpp.hpp>

#include "DLModuleLoader.h"

FIXTURE(DLModuleLoader)
{
   DLModuleLoader* loader;
   
   SETUP()
   {
      loader = new DLModuleLoader();
   }

   TEARDOWN()
   {
      delete loader;
   }

   TEST(可以在不需要指明后缀".so"的情况下加载一个模块)
   {
      ASSERT_THROWS_NOTHING(loader->load("libMySuite"));
   }

   TEST(可以在指明后缀".so"的情况下加载一个模块)
   { 
      ASSERT_THROWS_NOTHING(loader->load("libMySuite.so"));
   }
};

}}}

像任何正确实现的xUnit框架一样，*TestNG++* 会为每个测试用例创建一个Fixture实例，并执行其 *SETUP* 和 *TEARDOWN* 。对于本例中的两个用例，其执行过程分别如下：

  # new FixtureDLModuleLoader() 
  # SETUP() 
  # TEST(可以在不需要指明后缀".so"的情况下加载一个模块) 
  # TEARDOWN() 
  # delete FixtureDLModuleLoader;

  # new FixtureDLModuleLoader() 
  # SETUP() 
  # TEST(可以在指明后缀".so"的情况下加载一个模块) 
  # TEARDOWN() 
  # delete FixtureDLModuleLoader;

==1.6 Assertion==

|| 断言 || 用法 || 例子 ||
|| ASSERT_TRUE(expr) || 断言表达式的求值为true || ASSERT_TRUE(10 == a) ||
|| ASSERT_FALSE(expr) || 断言表达式的求值为false || ASSERT_FALSE(10 != a) ||
|| ASSERT_EQ(expected, value) || 断言两个表达式相等 || ASSERT_EQ(10, a) ||
|| ASSERT_NE(expected, value) || 断言两个表达式不相等 || ASSERT_NE(10, a) ||
|| ASSERT_SAME_DATA(addr1, addr2, size) || 断言两个地址所指向的内存在size范围内完全相同 || ASSERT_SAME_DATA(p1, p2, 64) ||
|| ASSERT_DELTA(x, y, delta) || 断言表达式的差值应该在delta的范围之内 || ASSERT_DELTA(9.91, 10, 0.1) ||
|| ASSERT_THROWS(expr, except) || 断言表达式将会抛出except类型的异常 || ASSERT_THROWS(foo(), std::exception) ||
|| ASSERT_THROWS_ANYTHING(expr) || 断言表达式将会抛出异常 || ASSERT_THROWS_ANYTHING(foo()) ||
|| ASSERT_THROWS_NOTHING(expr) || 断言expr不会抛出任何异常 || ASSERT_FALSE(10 != a) ||
|| ASSERT_THROWS_EQUALS(expr, except, expected, value) || 断言表达式将会抛出except类型的异常，并且两个表达式相等 || ASSERT_THROWS_EQUALS(foo(), std::exception& e, "bad alloc", e.what()) ||