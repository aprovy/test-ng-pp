<wiki:toc max_depth="3" />
=1 安装=

TestNG++使用[http://www.cmake.org cmake]作为构建系统。因此，为了构建TestNG++，你需要要确保cmake 2.6以上版本已经安装在你的系统上。

到TestNG++的[http://code.google.com/p/test-ng-pp/downloads/list 下载页面]下载最新的发布版本。尽管你可以直接从源代码库checkout最新的源代码，但它的稳定性无法得到保证。

==1.1 Linux/Mac OS==

随后将源代码包解压到某个目录。假社在Linux平台上，我们解压的目录是：/home/arthur/testngpp. 
{{{
arthur> cd /home/arthur/testngpp

arthur> mkdir build

arthur> cd build
}}}

然后运行cmake，此时，你可以通过变量 *CMAKE_INSTALL_PREFIX* 指定 *TestNG++* 的安装路径。如果你不指定，则默认的安装路径是/usr/local。

假设，我们想把TestNG++安装到目录/home/arthur/myproject :
{{{

arthur> cmake -DCMAKE_INSTALL_PREFIX=/home/arthur/myproject ..

-- The C compiler identification is GNU
-- The CXX compiler identification is GNU
-- Checking whether C compiler has -isysroot
-- Checking whether C compiler has -isysroot - yes
-- Check for working C compiler: /usr/bin/gcc
-- Check for working C compiler: /usr/bin/gcc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Checking whether CXX compiler has -isysroot
-- Checking whether CXX compiler has -isysroot - yes
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Found PythonInterp: /usr/bin/python2.5
-- Configuring done
-- Generating done
-- Build files have been written to: /home/arthur/testngpp/build

arthur> make

}}}

在成功构建之后。执行:

{{{
arthur> make install 
}}}

然后，在安装目录/home/arthur/myproject，你可以看到一个这样的目录结构：

{{{

 |- include
 |- bin
 |- lib
 |- testngpp |- generator
             |- listener

}}}

下表列出了各个目录所放置的内容:

|| 目录 || 内容 ||
|| include || 测试用例需要包含的头文件 ||
|| bin       || Test Runner等可执行文件 ||
|| lib        || 测试模块需要链接的库文件 ||
|| testngpp/generator || 测试代码产生器 ||
|| testngpp/listener || 测试结果监听器 ||

==1.2 Windows==

=2 编写测试 =

在你编写测试之前，你需要配置并安装*TestNG++*。

==2.1 测试文件==

为了使用*TestNG++*，你首先要创建放置测试代码的源代码文件，尽管并不是强制的约束，但建议使用".h"作为这些文件的扩展名。

比如，我们要测试的类名为DLModuleLoader，所以，我们可以将我们的测试文件命名为TestDLModuleLoader.h。

==2.2 头文件==

然后，你需要包含*TestNG++*的头文件 _*testngpp.hpp*_ ；像这样：
{{{
#include <testngpp/testngpp.hpp>
}}}

为了能够让编译通过，不要忘记把 *TestNG++* 的安装路径的include放到编译选项里。假如 *TestNG++* 的头文件被安装到/usr/local/include下，则你需要确保/usr/local/include被指定在你的编译选项里。对于windows用户而言，假设 *TestNG++* 被安装在c:\testngpp，则你需要将路径c:\testngpp\include放到你的编译选项里。

==2.3 FIXTURE==

下面，我们需要定义一个 *fixture*:

{{{
#include <testngpp/testngpp.hpp>

#include "DLModuleLoader.h"

FIXTURE(DLModuleLoader)
{
};

}}}

*FIXTURE()* 的第一个参数为 *Fixture ID* ，它可以是任何C/C++标识符（Identifier）。一般而言，将其命名为 *CUT* (_Class Under Test_)的名字即可。

*FIXTURE()* 还有第二个可选参数：*Fixture Name* 。它可以是任何_宏参数_所允许的字符。如果你的编译器支持多语言，你可以使用任何其它字符集所支持的字符。比如：

{{{
#include <testngpp/testngpp.hpp>

#include "DLModuleLoader.h"

FIXTURE(DLModuleLoader, 类DLModuleLoader的测试, 你可以在fixture name中使用这些字符：(){}[]''~!@#$%^&*+-=_?><"")
{
};

}}}

*FIXTURE* 本身是一个宏，所以要求*fixture name* 必须遵守宏参数的语法规则，你可以在名字里使用() ' "等符号，但它们必须正确的成对出现，否则编译器将会报错。

如果你没有提供 *fixture name* ，则 *fixture ID* 将被当作 *fixture name* 。

==2.4 TEST==

在定义了fixture之后，你可以编写你的第一个测试。如下：

{{{
#include <testngpp/testngpp.hpp>

#include "DLModuleLoader.h"

FIXTURE(DLModuleLoader)
{
   TEST(should be able to load modules whose name does not have suffix ".so")
   {
      DLModuleLoader* loader = new DLModuleLoader();
  
      ASSERT_THROWS_NOTHING(loader->load("libMySuite"));

      delete loader;
   }
};

}}}

*TEST()* 用来定义一个测试用例。括号里面的部分是 *test name* ，和 *fixture name* 一样，它可以使用你的编译器和所允许的任何字符。并且，同样也要遵守宏参数的语法约束。

比如，我可以将上面的测试用例用中文来命名：
{{{
#include <testngpp/testngpp.hpp>

#include "DLModuleLoader.h"

FIXTURE(DLModuleLoader)
{
   TEST(可以在不需要指明后缀".so"的情况下加载一个模块)
   {
      DLModuleLoader* loader = new DLModuleLoader();
  
      ASSERT_THROWS_NOTHING(loader->load("libMySuite"));

      delete loader;
   }
};

}}}

==2.5 Assertion==

测试用例里面的 *ASSERT_THROWS_NOTHING* 是一个测试断言，如果断言失败，则此测试用例将会失败。

TestNG++提供的测试断言如下：

|| 断言 || 用法 || 例子 ||
|| ASSERT_TRUE(expr) || 断言表达式的求值为true || ASSERT_TRUE(10 == a) ||
|| ASSERT_FALSE(expr) || 断言表达式的求值为false || ASSERT_FALSE(10 != a) ||
|| ASSERT_EQ(expected, value) || 断言两个表达式相等 || ASSERT_EQ(10, a) ||
|| ASSERT_NE(expected, value) || 断言两个表达式不相等 || ASSERT_NE(10, a) ||
|| ASSERT_SAME_DATA(addr1, addr2, size) || 断言两个地址所指向的内存在size范围内完全相同 || ASSERT_SAME_DATA(p1, p2, 64) ||
|| ASSERT_DELTA(x, y, delta) || 断言表达式的差值应该在delta的范围之内 || ASSERT_DELTA(9.91, 10, 0.1) ||
|| ASSERT_THROWS(expr, except) || 断言表达式将会抛出except类型的异常 || ASSERT_THROWS(foo(), std::exception) ||
|| ASSERT_THROWS_ANYTHING(expr) || 断言表达式将会抛出异常 || ASSERT_THROWS_ANYTHING(foo()) ||
|| ASSERT_THROWS_NOTHING(expr) || 断言expr不会抛出任何异常 || ASSERT_THROWS_NOTHING(foo()) ||
|| ASSERT_THROWS_EQUALS(expr, except, expected, value) || 断言表达式将会抛出except类型的异常，并且两个表达式相等 || ASSERT_THROWS_EQUALS(foo(), std::exception& e, "bad alloc", e.what()) ||

这些断言的都遵从了 *"快速失败"* 的原则，即一旦断言失败，整个用例将中止执行。


===2.5.1 EXPECT vs. ASSERT===

”快速失败“是个好的原则，但对于C++这种需要程序员自己进行资源管理的语言而言，有时候快速失败可能会带来问题。比如，对于这个例子，如果断言失败将会造成内存泄露。

{{{
   TEST(可以在不需要指明后缀".so"的情况下加载一个模块)
   {
      DLModuleLoader* loader = new DLModuleLoader();
  
      ASSERT_THROWS_NOTHING(loader->load("libMySuite"));

      delete loader; // 如果上面的断言失败，此语句将得不到执行
   }
}}}

所以，*TestNG++* 提供了另外一套Assertion，以让断言失败后，测试能够继续得以执行。这些Assertion如下：

|| 断言 || 用法 || 例子 ||
|| EXPECT_TRUE(expr) || 断言表达式的求值为true || EXPECT_TRUE(10 == a) ||
|| EXPECT_FALSE(expr) || 断言表达式的求值为false || EXPECT_FALSE(10 != a) ||
|| EXPECT_EQ(expected, value) || 断言两个表达式相等 || EXPECT_EQ(10, a) ||
|| EXPECT_NE(expected, value) || 断言两个表达式不相等 || EXPECT_NE(10, a) ||
|| EXPECT_SAME_DATA(addr1, addr2, size) || 断言两个地址所指向的内存在size范围内完全相同 || EXPECT_SAME_DATA(p1, p2, 64) ||
|| EXPECT_DELTA(x, y, delta) || 断言表达式的差值应该在delta的范围之内 || EXPECT_DELTA(9.91, 10, 0.1) ||
|| EXPECT_THROWS(expr, except) || 断言表达式将会抛出except类型的异常 || EXPECT_THROWS(foo(), std::exception) ||
|| EXPECT_THROWS_ANYTHING(expr) || 断言表达式将会抛出异常 || EXPECT_THROWS_ANYTHING(foo()) ||
|| EXPECT_THROWS_NOTHING(expr) || 断言expr不会抛出任何异常 || EXPECT_THROWS_NOTHING(foo()) ||
|| EXPECT_THROWS_EQUALS(expr, except, expected, value) || 断言表达式将会抛出except类型的异常，并且两个表达式相等 || EXPECT_THROWS_EQUALS(foo(), std::exception& e, "bad alloc", e.what()) ||

这样，上面用例就可以改写为：

{{{
   TEST(可以在不需要指明后缀".so"的情况下加载一个模块)
   {
      DLModuleLoader* loader = new DLModuleLoader();
  
      EXPECT_THROWS_NOTHING(loader->load("libMySuite"));

      delete loader; // 即使上面的断言失败，此语句仍将得到执行
   }
}}}

对于这个例子，EXPECT工作的很好。但在另外一些情况下，它将会导致晦涩复杂的测试。比如：

{{{
   TEST(应该能够根据名字找到相应的test case)
   {
      DLModuleLoader* loader = new DLModuleLoader();
      
      Suite* suite = 0;
      EXPECT_THROW_NOTHING(suite = loader->load("libMySuite"));
      EXPECT_TRUE( 0 != suite);
      if(suite != 0)
      {
          Fixture* fixture = suite->findFixture("MyFixture");
          EXPECT_TRUE(0 != fixture);
          if(fixture != 0)
          {
               TestCase* testcase = fixture->findTestCase("MyTestCase");
               EXPECT_TRUE(0 != testcase);
               EXPECT_EQ("MyTestCase", testcase->getName());
          }
      }

      delete loader; 
   }
}}}

===2.5.2 用例级别的资源管理===

*TestNG++* 提供了另外一种机制来帮助编写简单的测试。

{{{
   TEST(应该能够根据名字找到相应的test case)
   {
      DLModuleLoader* loader = new DLModuleLoader();

      __DO__      // 从这里开始是可能失败的部分
      
      Suite* suite = 0;
      ASSERT_THROW_NOTHING(suite = loader->load("libMySuite"));
      ASSERT_TRUE( 0 != suite );

      Fixture* fixture = suite->findFixture("MyFixture");
      ASSERT_TRUE( 0 != fixture );
     
      TestCase* testcase = fixture->findTestCase("MyTestCase");
      ASSERT_TRUE( 0 != testcase );
      ASSERT_EQ("MyTestCase", testcase->getName());
      
      __CLEANUP__ // 无论__DO__里面的断言失败与否，__CLEANUP__里面的代码都会得到执行

      delete loader;

      __DONE__ // 不要忘了写它 
   }
}}}

由于`__DO__`里面的每一个断言都用的是“快速失败”Assertion，所以任何一个断言失败都会导致`__DO__`的部分立即中止，但`__CLEANUP__`的部分却无论成功与失败都肯定会得到执行。这种机制也可以被理解为用例级别的setup/teardown。

===2.5.3 特别的Assertion===

另外，*TestNG++* 还提供了另外几个Assertion用于特殊的目的。

|| 断言 || 用法 || 例子 ||
|| FAIL(str) || 让用例立即失败，并给出失败的原因 || FAIL("not implemented yet") ||
|| WARN(str) || 给出一个警告，但用例并不失败 || WARN(“got a non-fatal null pointer.”) ||
|| INFO(str) || 给出一个信息，用例并不失败 || INFO(“resource has been released.”) ||

==2.6 SETUP和TEARDOWN==

在测试成功运行之后，我们来编写第二个用例。

{{{
#include <testngpp/testngpp.hpp>

#include "DLModuleLoader.h"

FIXTURE(DLModuleLoader)
{
   TEST(可以在不需要指明后缀".so"的情况下加载一个模块)
   {
      DLModuleLoader* loader = new DLModuleLoader();
  
      ASSERT_THROWS_NOTHING(loader->load("libMySuite"));

      delete loader;
   }

   TEST(可以在指明后缀".so"的情况下加载一个模块)
   {
      DLModuleLoader* loader = new DLModuleLoader();
  
      ASSERT_THROWS_NOTHING(loader->load("libMySuite.so"));

      delete loader;
   }
};

}}}

然后我们发现，两个用例都需要使用一个loader实例，所以我们把这个实例定义移到fixture里面，并使用fixture的 *SETUP* 和 *TEARDOWN* ：


{{{
#include <testngpp/testngpp.hpp>

#include "DLModuleLoader.h"

FIXTURE(DLModuleLoader)
{
   DLModuleLoader* loader;
   
   SETUP()
   {
      loader = new DLModuleLoader();
   }

   TEARDOWN()
   {
      delete loader;
   }

   TEST(可以在不需要指明后缀".so"的情况下加载一个模块)
   {
      ASSERT_THROWS_NOTHING(loader->load("libMySuite"));
   }

   TEST(可以在指明后缀".so"的情况下加载一个模块)
   { 
      ASSERT_THROWS_NOTHING(loader->load("libMySuite.so"));
   }
};

}}}

像任何正确实现的xUnit框架一样，*TestNG++* 会为每个测试用例创建一个Fixture实例，并执行其 *SETUP* 和 *TEARDOWN* 。对于本例中的两个用例，其执行过程分别如下：

  # new FixtureDLModuleLoader() 
  # SETUP() 
  # TEST(可以在不需要指明后缀".so"的情况下加载一个模块) 
  # TEARDOWN() 
  # delete FixtureDLModuleLoader;

  # new FixtureDLModuleLoader() 
  # SETUP() 
  # TEST(可以在指明后缀".so"的情况下加载一个模块) 
  # TEARDOWN() 
  # delete FixtureDLModuleLoader;

另外，可以保证的是，无论测试失败与否，TEARDOWN都肯定会得到执行。

==2.7 测试依赖==

随后我们编写针对unload的测试，传统的做法如下：

{{{
#include <testngpp/testngpp.hpp>

#include "DLModuleLoader.h"

FIXTURE(DLModuleLoader)
{
   DLModuleLoader* loader;
   
   SETUP()
   {
      loader = new DLModuleLoader();
   }

   TEARDOWN()
   {
      delete loader;
   }

   TEST(可以在不需要指明后缀".so"的情况下加载一个模块)
   {
      ASSERT_THROWS_NOTHING(loader->load("libMySuite"));
   }

   TEST(可以在指明后缀".so"的情况下加载一个模块)
   { 
      ASSERT_THROWS_NOTHING(loader->load("libMySuite.so"));
   }

   TEST(可以在加载后卸载模块)
   {
      ASSERT_THROWS_NOTHING(loader->load("libMySuite.so"));
      ASSERT_THROWS_NOTHING(loader->unload());
   }
};

}}}

由于卸载的前提是先加载模块，而加载模块的测试我们已经编写过，所以我们不想重复这段代码。另外一个选择是：使用测试依赖。改写结果如下：

{{{
#include <testngpp/testngpp.hpp>

#include "DLModuleLoader.h"

FIXTURE(DLModuleLoader)
{
   DLModuleLoader* loader;
   
   SETUP()
   {
      loader = new DLModuleLoader();
   }

   TEARDOWN()
   {
      delete loader;
   }

   TEST(可以在不需要指明后缀".so"的情况下加载一个模块)
   {
      ASSERT_THROWS_NOTHING(loader->load("libMySuite"));
   }

   // @ test (id=load)
   TEST(可以在指明后缀".so"的情况下加载一个模块)
   { 
      ASSERT_THROWS_NOTHING(loader->load("libMySuite.so"));
   }

   // @ test (depends=load)
   TEST(可以在加载后卸载模块)
   {
      ASSERT_THROWS_NOTHING(loader->unload());
   }
};

}}}

通过annotation属性id来标注加载测试用例，然后用属性depends来引入依赖。

引入测试依赖后，最后一个测试用例的执行过程如下：

  # new FixtureDLModuleLoader() 
  # SETUP()
  # TEST(可以在指明后缀".so"的情况下加载一个模块)
  # TEST(可以在加载后卸载模块)
  # TEARDOWN() 
  # delete FixtureDLModuleLoader;

在这个过程中，即便TEST(可以在指明后缀".so"的情况下加载一个模块)里面的断言失败，*TestNG++*仍然认为是用例TEST(可以在加载后卸载模块)失败。

==2.8 兼容性==

===2.8.1 cxxtest===

===2.8.2 testcpp===

=3. 编译和链接=

Coming...

==Test Suite==

Coming...

==Generator==

Coming...

=4. 运行=

Coming...

==Test Runner==

Coming...

==运行模式==

===Flat模式===

===Sandbox模式===

==Test Listener==

===Stdout Listener===

===XML Listener===

==Tags==

Coming...