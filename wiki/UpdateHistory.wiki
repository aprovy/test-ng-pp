#这是testngpp的更新历史

= 更新历史 =

== 2011.3.17 ==

1、内存泄露改为两次运行检查，避免误报。

背景：
    如果用到全局的vector变量（或其它STL类型的变量），由于STL考虑到性能优化，容器申请的内存在容器元素删除时并不会释放，而是在vector析构时才释放。
    这就会导致testngpp误报了一些内存泄露。
    一般来讲，一个用例运行完应该把所有更改的数据恢复原样，所以一个用例第一次运行有泄露，如果再运行一次，没有了泄露，那么第一次运行的泄露应该也不是用户代码引起的，很可能是前面描述的那种情况。这种情况下，应该不报告内存泄露。所以有了下面策略。

策略：
 # 如果一个用例运行第一遍有内存泄露，并不立即报告，而是运行第二次。
 # 如果第二次没有内存泄露则该用例不报告内存泄露；如果第二次有泄露则报告内存泄露。

注意：
    本次修改后，内存泄露检查在fixture析构之前进行的，暂时没有想到fixture析构之后检查的简单办法，而且由于有了两次检查机制，正常使用情况下，误报基本不会出现。所以暂时未处理此问题。

== 2011.3.20 ==

1、增加ASSERT_DBL_EQ/NE用于判断float/double/long double是否相等。

注意：判断时使用的fabs(a-b)<FLT_EPSILON，不能用DBL_EPSILON，否则有float参与运算时，精度达不到，就会出现0.7 != 0.7的情况。


2、增加关闭用例内存泄露检查的方法：tags = "nomemcheck" 。

注意：
~~  # 内存泄露检查是默认开启的，暂时无法在命令行关闭（还没想到简单办法实现它，也不想破坏了现在软件的结构^_^）~~
~~  # 暂时不支持FIXTURE的内存泄露检查控制。~~
~~  # 针对用例，也无法打开内存泄露。（暂时用不着）~~



== 2011.3.25 ==

1、内存泄露检查开关完善。

  # 如果命令行加了-m选项，则该次执行不再检查内存泄露（即使在Fixture/TestCase级别打开也没用）。
  # 如果命令行没有-m选项，默认是会进行内存泄露检查的，具体的Fixture/TestCase的内存泄露是否检查由它们的tags确定。
  # Fixture/TestCase的Annotation中增加memcheck开关，用于控制是否进行内存泄露检查：memcheck = on 表示检查，off表示不检查，两者都没有也表示检查。
  # Fixture设置的memcheck开关，会影响到它的每一个用例，但Fixture的设置优先级比TestCase的要低。（可以在Fixture级别关闭，再在TestCase级别打开）

  使用示例如下：

{{{
//@fixture(memcheck=on)
FIXTURE(TestFixtureMemCheckOnAnnotation)
{
   TEST(fixture has been set to memcheck on, its tests all memcheck on)
   {
       char *p = new char; // should fail       
   }

   //@test(memcheck=off)
   TEST(fixture has been set to memcheck on, its test can use memcheck off to close mem leak check)
   {
   	   char *p = new char;
   }
};
}}}

注意：
  # 去掉了STOP/OPEN_MEM_CHECKER两个接口。